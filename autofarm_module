-- ===== AUTOFARM MODULE =====
-- –ú–æ–¥—É–ª—å –∞–≤—Ç–æ—Ñ–∞—Ä–º–∞ —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ–º –ø–æ–∑–∏—Ü–∏–π –ø—Ä–µ–¥–º–µ—Ç–æ–≤
-- –ó–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω–æ —á–µ—Ä–µ–∑ ModuleLoader –¥–ª—è —Ä–µ—à–µ–Ω–∏—è –ø—Ä–æ–±–ª–µ–º—ã local registers

print("üöú –ó–∞–≥—Ä—É–∂–∞–µ–º –º–æ–¥—É–ª—å Autofarm...")

-- –ü–æ–ª—É—á–∞–µ–º –¥–æ—Å—Ç—É–ø –∫ —É—Ç–∏–ª–∏—Ç–∞–º –∏ —Å–µ—Ä–≤–∏—Å–∞–º
local Utils = _G.ModuleUtils
local Services = Utils.Services
local Players = Services.Players
local RunService = Services.RunService
local UserInputService = Services.UserInputService

-- –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∞–≤—Ç–æ—Ñ–∞—Ä–º–∞
local AutofarmConfig = {
    Enabled = false,
    UseFlightMovement = true,
    UseNoClipMovement = true,
    FlightSpeed = 100,
    PickupRadius = 8,
    PickupDuration = 0.25,
    PickupKey = Enum.KeyCode.E,
    ScanInterval = 1,
    Items = {
        ["Mysterious Arrow"] = true,
        ["Rokakaka"] = true,
        ["Pure Rokakaka"] = true,
        ["Diamond"] = true,
        ["Gold Coin"] = true,
        ["Steel Ball"] = true,
        ["Clackers"] = true,
        ["Caesar's Headband"] = true,
        ["Zeppeli's Hat"] = true,
        ["Zeppeli's Scarf"] = true,
        ["Ancient Scroll"] = true,
        ["Quinton's Glove"] = false,
        ["Stone Mask"] = true,
        ["Lucky Arrow"] = true,
        ["Lucky Stone Mask"] = true,
        ["Rib Cage of The Saint's Corpse"] = true,
        ["DIO's Diary"] = true,
        ["Dio's Diary"] = true,
    }
}

-- –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∞–≤—Ç–æ—Ñ–∞—Ä–º–∞
local AutofarmState = {
    isEnabled = false,
    connections = {},
    currentTarget = nil,
    itemAttempts = {},
    skippedItems = {},
    originalPosition = nil,
    pickingUp = false,
    originalGravity = workspace.Gravity
}

-- –û—Å–Ω–æ–≤–Ω–æ–π –æ–±—ä–µ–∫—Ç –º–æ–¥—É–ª—è
local AutofarmModule = {}

-- –£—Ç–∏–ª–∏—Ç—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –ø—Ä–µ–¥–º–µ—Ç–∞–º–∏
local function getItemKey(item)
    return item.Name .. "_" .. tostring(item.Position.X) .. "_" .. tostring(item.Position.Z)
end

local function resetItemAttempts(itemKey)
    AutofarmState.itemAttempts[itemKey] = nil
end

local function incrementItemAttempts(itemKey)
    AutofarmState.itemAttempts[itemKey] = (AutofarmState.itemAttempts[itemKey] or 0) + 1
    return AutofarmState.itemAttempts[itemKey]
end

local function isItemMaxAttempts(itemKey)
    return (AutofarmState.itemAttempts[itemKey] or 0) >= 3
end

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–π –ø–æ–∑–∏—Ü–∏–∏ –ø—Ä–µ–¥–º–µ—Ç–∞ –∏–∑ BodyPosition
local function getCurrentItemPosition(item)
    if not item or not item.Model then
        return nil
    end
    
    -- –ò—â–µ–º –ø–µ—Ä–≤—É—é –ø–∞–ø–∫—É MeshPart –≤ model
    local meshPart = nil
    for _, child in ipairs(item.Model:GetChildren()) do
        if child:IsA("MeshPart") then
            meshPart = child
            break
        end
    end
    
    if meshPart then
        -- –ò—â–µ–º BodyPosition –≤ MeshPart
        local bodyPosition = meshPart:FindFirstChild("BodyPosition")
        if bodyPosition and bodyPosition.Position then
            return bodyPosition.Position
        end
    end
    
    -- Fallback –∫ —Å—Ç–∞—Ç–∏—á–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏ –ø—Ä–µ–¥–º–µ—Ç–∞
    return item.Position
end

-- –§—É–Ω–∫—Ü–∏—è –ø–æ–∏—Å–∫–∞ –ø—Ä–µ–¥–º–µ—Ç–æ–≤ –¥–ª—è –∞–≤—Ç–æ—Ñ–∞—Ä–º–∞
local function findAutofarmItems()
    local items = {}
    local player = Players.LocalPlayer
    local playerChar = player.Character
    local playerRoot = playerChar and playerChar:FindFirstChild("HumanoidRootPart")
    if not playerRoot then 
        print("AUTOFARM: –ò–≥—Ä–æ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return items 
    end

    print("AUTOFARM: –ù–∞—á–∏–Ω–∞–µ–º –ø–æ–∏—Å–∫ –ø—Ä–µ–¥–º–µ—Ç–æ–≤...")
    local foundCount = 0

    for _, model in pairs(workspace:GetChildren()) do
        if model:IsA("Model") then
            local proximityPrompt = model:FindFirstChild("ProximityPrompt")
            local itemName = model.Name
            
            if proximityPrompt then
                itemName = proximityPrompt.ObjectText or proximityPrompt.ActionText or model.Name
            end
            
            -- –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è –¥–Ω–µ–≤–Ω–∏–∫–∞ –î–ò–û (—Ä–∞–∑–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –Ω–∞–∑–≤–∞–Ω–∏–π)
            if itemName == "Dio's Diary" and AutofarmConfig.Items["DIO's Diary"] then
                itemName = "DIO's Diary"
            end
            
            -- –°—Ç–∞–Ω–¥–∞—Ä—Ç–∏–∑–∏—Ä—É–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ —Å—Ç—Ä–µ–ª
            local shouldSkipItem = false
            if string.find(string.lower(itemName), "arrow") and not AutofarmConfig.Items["Mysterious Arrow"] then
                shouldSkipItem = true
            end
            
            if not shouldSkipItem and string.find(string.lower(itemName), "arrow") and itemName ~= "Mysterious Arrow" then
                itemName = "Mysterious Arrow"
            end
            
            if not shouldSkipItem and AutofarmConfig.Items[itemName] then
                -- –ò—â–µ–º –ø–æ–∑–∏—Ü–∏—é –≤ model -> MeshPart -> BodyPosition.Position
                local worldPivot = nil
                
                -- –ò—â–µ–º –ø–µ—Ä–≤—É—é –ø–∞–ø–∫—É MeshPart –≤ model
                local meshPart = nil
                for _, child in ipairs(model:GetChildren()) do
                    if child:IsA("MeshPart") then
                        meshPart = child
                        break
                    end
                end
                
                if meshPart then
                    -- –ò—â–µ–º BodyPosition –≤ MeshPart
                    local bodyPosition = meshPart:FindFirstChild("BodyPosition")
                    if bodyPosition and bodyPosition.Position then
                        worldPivot = bodyPosition.Position
                        print("AUTOFARM: –ù–∞–π–¥–µ–Ω–∞ –ø–æ–∑–∏—Ü–∏—è —á–µ—Ä–µ–∑ BodyPosition:", worldPivot)
                    end
                end
                
                -- Fallback: –µ—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω BodyPosition, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞—Ä—É—é –ª–æ–≥–∏–∫—É
                if not worldPivot then
                    print("AUTOFARM: BodyPosition –Ω–µ –Ω–∞–π–¥–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º fallback –ª–æ–≥–∏–∫—É –¥–ª—è", itemName)
                    if model.WorldPivot then
                        worldPivot = model.WorldPivot.Position
                    elseif model.PrimaryPart then
                        worldPivot = model.PrimaryPart.Position
                    elseif model:FindFirstChild("HumanoidRootPart") then
                        worldPivot = model.HumanoidRootPart.Position
                    else
                        -- –ò—â–µ–º –ª—é–±—É—é Part
                        for _, child in ipairs(model:GetDescendants()) do
                            if child:IsA("BasePart") then
                                worldPivot = child.Position
                                break
                            end
                        end
                    end
                end
                
                if worldPivot then
                    local distance = (worldPivot - playerRoot.Position).Magnitude
                    foundCount = foundCount + 1
                    local tempItem = {
                        Name = itemName,
                        Position = worldPivot,
                        Distance = distance,
                        Model = model,
                        ProximityPrompt = proximityPrompt
                    }
                    local itemKey = getItemKey(tempItem)
                    
                    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ –ø—Ä–µ–≤—ã—à–µ–Ω–æ –ª–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫
                    if not isItemMaxAttempts(itemKey) then
                        -- –õ–æ–≥–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—É—é –ø–æ–ø—ã—Ç–∫—É –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç–∞, —á—Ç–æ–±—ã –Ω–µ —Å–ø–∞–º–∏—Ç—å
                        if (AutofarmState.itemAttempts[itemKey] or 0) == 0 then
                            print("AUTOFARM: üéØ –ù–∞–π–¥–µ–Ω –ø—Ä–µ–¥–º–µ—Ç", itemName, "–Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏", math.floor(distance), "–º")
                        end
                        table.insert(items, tempItem)
                    else
                        print("AUTOFARM: –ü—Ä–µ–¥–º–µ—Ç", itemName, "–ø—Ä–æ–ø—É—â–µ–Ω - –ø—Ä–µ–≤—ã—à–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫ (3/3)")
                        AutofarmState.skippedItems[itemKey] = tempItem
                    end
                end
            end
        end
    end
    
    -- –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—é (–±–ª–∏–∂–∞–π—à–∏–µ –ø–µ—Ä–≤—ã–º–∏)
    table.sort(items, function(a, b) return a.Distance < b.Distance end)
    
    return items
end

-- –§—É–Ω–∫—Ü–∏—è –¥–≤–∏–∂–µ–Ω–∏—è –∫ –ø–æ–∑–∏—Ü–∏–∏ —Å –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–º –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ–º
local function moveToPosition(targetPosition, callback, trackingItem)
    local player = Players.LocalPlayer
    local character = player.Character
    if not character then
        print("AUTOFARM: –ü–µ—Ä—Å–æ–Ω–∞–∂ –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return false
    end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then
        print("AUTOFARM: HumanoidRootPart –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return false
    end
    
    -- –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º NoClip —É —Å–∏—Å—Ç–µ–º—ã –º–æ–¥—É–ª–µ–π
    if AutofarmConfig.UseNoClipMovement then
        _G.ModuleEvents.fire("RequestNoClip", true)
    end
    
    -- –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –¥–ª—è –ø–æ–ª–µ—Ç–∞
    local humanoid = character:FindFirstChild("Humanoid")
    if humanoid then
        humanoid.JumpPower = 0
        humanoid.JumpHeight = 0
        humanoid.HipHeight = 0
    end
    
    -- –°–æ–∑–¥–∞–µ–º BodyVelocity –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è
    local bodyVelocity = humanoidRootPart:FindFirstChild("AutofarmBodyVelocity")
    if not bodyVelocity then
        bodyVelocity = Instance.new("BodyVelocity")
        bodyVelocity.Name = "AutofarmBodyVelocity"
        bodyVelocity.MaxForce = Vector3.new(9e9, 9e9, 9e9)
        bodyVelocity.Parent = humanoidRootPart
    end
    
    -- –û—Ç–∫–ª—é—á–∞–µ–º –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—é –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
    if AutofarmConfig.UseFlightMovement then
        workspace.Gravity = 0
        print("AUTOFARM: –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è –æ—Ç–∫–ª—é—á–µ–Ω–∞")
    end
    
    -- –¢–†–Å–•–≠–¢–ê–ü–ù–û–ï –î–í–ò–ñ–ï–ù–ò–ï —Å –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–º –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ–º
    local currentStage = 1
    local currentPos = humanoidRootPart.Position
    local stage1Target = Vector3.new(currentPos.X, -70, currentPos.Z)
    local stage2Target = Vector3.new(targetPosition.X, -70, targetPosition.Z)
    local stage3Target = Vector3.new(targetPosition.X, targetPosition.Y - 2, targetPosition.Z)
    
    print("AUTOFARM: üéØ –¢—Ä—ë—Ö—ç—Ç–∞–ø–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –∫ –ø–æ–∑–∏—Ü–∏–∏", targetPosition)
    print("AUTOFARM: –≠—Ç–∞–ø 1: –°–ø—É—Å–∫ –Ω–∞ Y=-70 ->", stage1Target)
    print("AUTOFARM: –≠—Ç–∞–ø 2: –ü–æ–ª—ë—Ç –ø–æ X,Z ->", stage2Target) 
    print("AUTOFARM: –≠—Ç–∞–ø 3: –ü–æ–¥—ä—ë–º –∫ –ø—Ä–µ–¥–º–µ—Ç—É ->", stage3Target)
    
    local moveConnection = Utils.safeConnect(RunService.Heartbeat, function()
        if not AutofarmState.isEnabled then
            -- –ü—Ä–∏ –æ—Ç–∫–ª—é—á–µ–Ω–∏–∏ –∞–≤—Ç–æ—Ñ–∞—Ä–º–∞ –æ—á–∏—â–∞–µ–º BodyVelocity
            if bodyVelocity and bodyVelocity.Parent then
                bodyVelocity.Velocity = Vector3.new(0, 0, 0)
                bodyVelocity:Destroy()
            end
            if moveConnection then moveConnection:Disconnect() end
            return
        end
        
        local currentPos = humanoidRootPart.Position
        local currentTarget
        
        -- –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–µ–∫—É—â—É—é —Ü–µ–ª—å –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —ç—Ç–∞–ø–∞
        if currentStage == 1 then
            currentTarget = stage1Target
        elseif currentStage == 2 then
            currentTarget = stage2Target
        else
            -- –≠—Ç–∞–ø 3: –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –æ–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –ø—Ä–µ–¥–º–µ—Ç–∞ –µ—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω trackingItem
            if trackingItem then
                local currentItemPos = getCurrentItemPosition(trackingItem)
                if currentItemPos then
                    local newTarget = Vector3.new(currentItemPos.X, currentItemPos.Y - 2, currentItemPos.Z)
                    -- –õ–æ–≥–∏—Ä—É–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω–∏ –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω—ã–µ
                    if (newTarget - stage3Target).Magnitude > 0.5 then
                        print("AUTOFARM: üìç –ü–æ–∑–∏—Ü–∏—è –ø—Ä–µ–¥–º–µ—Ç–∞ –∏–∑–º–µ–Ω–∏–ª–∞—Å—å:", currentItemPos, "-> —Ü–µ–ª—å:", newTarget)
                    end
                    stage3Target = newTarget
                end
            end
            currentTarget = stage3Target
        end
        
        local distance = (currentTarget - currentPos).Magnitude
        
        if distance > 0.3 then
            local direction = (currentTarget - currentPos).Unit
            local dynamicSpeed = math.max(20, math.min(AutofarmConfig.FlightSpeed * 8, distance * 25))
            local moveVector = direction * dynamicSpeed
            bodyVelocity.Velocity = moveVector
        else
            -- –î–æ—Å—Ç–∏–≥–ª–∏ —Ç–µ–∫—É—â–µ–≥–æ —ç—Ç–∞–ø–∞
            bodyVelocity.Velocity = Vector3.new(0, 0, 0)
            
            if currentStage == 1 then
                print("AUTOFARM: ‚úÖ –≠—Ç–∞–ø 1 –∑–∞–≤–µ—Ä—à—ë–Ω - —Å–ø—É—Å—Ç–∏–ª–∏—Å—å –Ω–∞ Y=-70")
                currentStage = 2
            elseif currentStage == 2 then
                print("AUTOFARM: ‚úÖ –≠—Ç–∞–ø 2 –∑–∞–≤–µ—Ä—à—ë–Ω - –¥–æ—Å—Ç–∏–≥–ª–∏ –ø–æ–∑–∏—Ü–∏–∏ –ø–æ X,Z")
                currentStage = 3
            else
                -- –≠—Ç–∞–ø 3 –∑–∞–≤–µ—Ä—à—ë–Ω - –¥–æ—Å—Ç–∏–≥–ª–∏ –ø—Ä–µ–¥–º–µ—Ç–∞
                local finalDistance = (stage3Target - humanoidRootPart.Position).Magnitude
                print("AUTOFARM: ‚úÖ –≠—Ç–∞–ø 3 –∑–∞–≤–µ—Ä—à—ë–Ω - –¥–æ—Å—Ç–∏–≥–ª–∏ –ø—Ä–µ–¥–º–µ—Ç–∞, —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ:", math.floor(finalDistance * 10) / 10, "–º")
                
                if moveConnection then moveConnection:Disconnect() end
                if callback then
                    callback()
                end
            end
        end
    end)
    
    if moveConnection then
        table.insert(AutofarmState.connections, moveConnection)
    end
    return true
end

-- –û—Å–Ω–æ–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –º–æ–¥—É–ª—è
function AutofarmModule.start()
    if AutofarmState.isEnabled then
        print("AUTOFARM: –£–∂–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω!")
        return false
    end
    
    AutofarmState.isEnabled = true
    AutofarmConfig.Enabled = true
    print("AUTOFARM: üöú –ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω!")
    
    -- –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏—Å—Ö–æ–¥–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
    local player = Players.LocalPlayer
    local character = player.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        AutofarmState.originalPosition = character.HumanoidRootPart.Position
    end
    
    -- –ó–∞–ø—É—Å–∫–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø—Ä–µ–¥–º–µ—Ç–æ–≤
    task.spawn(function()
        while AutofarmState.isEnabled do
            local items = findAutofarmItems()
            if #items > 0 then
                local nextItem = items[1]
                print("AUTOFARM: ‚úàÔ∏è –õ–µ—Ç–∏–º –∫ –ø—Ä–µ–¥–º–µ—Ç—É", nextItem.Name, "–Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏", math.floor(nextItem.Distance), "–º")
                
                local targetPosition = nextItem.Position
                pcall(function()
                    moveToPosition(targetPosition, function()
                        if AutofarmState.isEnabled then
                            print("AUTOFARM: üéØ –î–æ—Å—Ç–∏–≥–ª–∏ –ø—Ä–µ–¥–º–µ—Ç–∞", nextItem.Name)
                            -- –ó–¥–µ—Å—å –±—É–¥–µ—Ç –ª–æ–≥–∏–∫–∞ –ø–æ–¥–±–æ—Ä–∞ –ø—Ä–µ–¥–º–µ—Ç–∞
                            _G.ModuleEvents.fire("ItemReached", nextItem)
                        end
                    end, nextItem)
                end)
            else
                print("AUTOFARM: –ü—Ä–µ–¥–º–µ—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã, –∂–¥–µ–º...")
            end
            task.wait(AutofarmConfig.ScanInterval)
        end
    end)
    
    -- –£–≤–µ–¥–æ–º–ª—è–µ–º –¥—Ä—É–≥–∏–µ –º–æ–¥—É–ª–∏
    _G.ModuleEvents.fire("AutofarmStarted")
    return true
end

function AutofarmModule.stop()
    if not AutofarmState.isEnabled then
        return false
    end
    
    AutofarmState.isEnabled = false
    AutofarmConfig.Enabled = false
    print("AUTOFARM: üõë –û—Ç–∫–ª—é—á–µ–Ω!")
    
    -- –û—á–∏—â–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
    Utils.cleanupConnections(AutofarmState.connections)
    AutofarmState.connections = {}
    
    -- –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—é
    workspace.Gravity = AutofarmState.originalGravity
    
    -- –û—á–∏—â–∞–µ–º BodyVelocity
    local player = Players.LocalPlayer
    local character = player.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        local root = character.HumanoidRootPart
        local bv = root:FindFirstChild("AutofarmBodyVelocity")
        if bv then
            bv:Destroy()
        end
    end
    
    -- –û—Ç–∫–ª—é—á–∞–µ–º NoClip
    _G.ModuleEvents.fire("RequestNoClip", false)
    
    -- –£–≤–µ–¥–æ–º–ª—è–µ–º –¥—Ä—É–≥–∏–µ –º–æ–¥—É–ª–∏
    _G.ModuleEvents.fire("AutofarmStopped")
    return true
end

function AutofarmModule.toggle()
    if AutofarmState.isEnabled then
        return AutofarmModule.stop()
    else
        return AutofarmModule.start()
    end
end

function AutofarmModule.isEnabled()
    return AutofarmState.isEnabled
end

function AutofarmModule.getConfig()
    return AutofarmConfig
end

function AutofarmModule.setConfig(newConfig)
    for key, value in pairs(newConfig) do
        if AutofarmConfig[key] ~= nil then
            AutofarmConfig[key] = value
        end
    end
end

function AutofarmModule.getStats()
    return {
        enabled = AutofarmState.isEnabled,
        currentTarget = AutofarmState.currentTarget,
        itemAttempts = AutofarmState.itemAttempts,
        skippedItems = AutofarmState.skippedItems,
        connections = #AutofarmState.connections
    }
end

-- –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –º–æ–¥—É–ª—å –≤ –≥–ª–æ–±–∞–ª—å–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏
_G.AutofarmModule = AutofarmModule

print("‚úÖ –ú–æ–¥—É–ª—å Autofarm –∑–∞–≥—Ä—É–∂–µ–Ω —É—Å–ø–µ—à–Ω–æ!")
print("üí° –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ _G.AutofarmModule.start() –¥–ª—è –∑–∞–ø—É—Å–∫–∞")
print("üí° –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ _G.AutofarmModule.stop() –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏")

return AutofarmModule